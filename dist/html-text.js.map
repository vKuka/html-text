{"version":3,"file":"html-text.js","sources":["../src/index.js"],"sourcesContent":["import { Sprite } from '@pixi/sprite';\r\nimport { settings } from '@pixi/settings';\r\nimport { Texture } from '@pixi/core';\r\nimport { Rectangle } from '@pixi/math';\r\nimport { trimCanvas, sign, hex2rgb, hex2string } from '@pixi/utils';\r\nimport { TextStyle } from '@pixi/text';\r\n\r\n/**\r\n * Text display object that support multi-style HTML text\r\n * @class\r\n * @memberof PIXI\r\n * @extends PIXI.Sprite\r\n * @see {@link https://pixijs.download/dev/docs/PIXI.Sprite.html PIXI.Sprite}\r\n * @see {@link https://pixijs.download/dev/docs/PIXI.TextStyle.html PIXI.TextStyle}\r\n */\r\nexport class HTMLText extends Sprite\r\n{\r\n    /**\r\n     * @constructor\r\n     * @param {string} [text] - Text contents\r\n     * @param {PIXI.TextStyle} [style] - Style settings, not all TextStyle options are supported.\r\n     * @param {HTMLCanvasElement} [canvas] - Optional canvas to use for rendering.\r\n     *.       if undefined, will generate it's own canvas using createElement.\r\n     * @param {object<string, string>} [cssStyle] - CSS Style settings for HTML elements in text\r\n     *        Where key is selector, value is styles\r\n     */\r\n    constructor(text = '', style = {}, canvas, cssStyle = {})\r\n    {\r\n        canvas = canvas || document.createElement('canvas');\r\n\r\n        canvas.width = 3;\r\n        canvas.height = 3;\r\n\r\n        const texture = Texture.from(canvas, { scaleMode: settings.SCALE_MODE });\r\n\r\n        texture.orig = new Rectangle();\r\n        texture.trim = new Rectangle();\r\n\r\n        super(texture);\r\n\r\n        this._parser = new DOMParser();\r\n        this._image = new Image();\r\n\r\n        this.canvas = canvas;\r\n        this.context = this.canvas.getContext('2d');\r\n        this._resolution = settings.RESOLUTION;\r\n        this._autoResolution = true;\r\n        this._text = null;\r\n        this._style = null;\r\n        this._cssStyle = null;\r\n        this._loading = false;\r\n        this.text = text;\r\n        this.style = style;\r\n        this.cssStyle = cssStyle;\r\n        this.localStyleID = -1;\r\n    }\r\n\r\n    /**\r\n     * Manually refresh the text.\r\n     * @public\r\n     * @param {boolean} [respectDirty=true] - Whether to abort updating the\r\n     *        text if the Text isn't dirty and the function is called.\r\n     */\r\n    updateText(respectDirty)\r\n    {\r\n        const { style, canvas, context, resolution } = this;\r\n\r\n        // check if style has changed..\r\n        if (this.localStyleID !== style.styleID)\r\n        {\r\n            this.dirty = true;\r\n            this.localStyleID = style.styleID;\r\n        }\r\n\r\n        if (!this.dirty && respectDirty)\r\n        {\r\n            return;\r\n        }\r\n\r\n        let css = `\r\n            display:inline-block;\r\n            color:${style.fill};\r\n            font-size: ${style.fontSize}px;\r\n            font-family:${style.fontFamily};\r\n            font-weight:${style.fontWeight};\r\n            font-style:${style.fontStyle};\r\n            font-variant:${style.fontVariant};\r\n            letter-spacing:${style.letterSpacing}px;\r\n            text-align:${style.align};\r\n            padding:${style.padding}px;\r\n        `;\r\n\r\n        if (style.lineHeight)\r\n        {\r\n            css += `line-height:${style.lineHeight}px;`;\r\n        }\r\n\r\n        if (style.wordWrap)\r\n        {\r\n            css += `word-wrap:${style.breakWords ? 'break-all' : 'break-word'};`;\r\n            css += `width:${style.wordWrapWidth}px;`;\r\n        }\r\n\r\n        if (style.strokeThickness)\r\n        {\r\n            let { stroke } = style;\r\n\r\n            if (typeof color === 'number')\r\n            {\r\n                stroke = hex2string(stroke);\r\n            }\r\n\r\n            css += `-webkit-text-stroke-width: ${style.strokeThickness}px;`;\r\n            css += `-webkit-text-stroke-color: ${stroke};`;\r\n            css += `text-stroke-width: ${style.strokeThickness}px;`;\r\n            css += `text-stroke-color: ${stroke};`;\r\n            css += 'paint-order: stroke;';\r\n        }\r\n\r\n        if (style.dropShadow)\r\n        {\r\n            const { dropShadowAngle, dropShadowDistance, dropShadowBlur, dropShadowColor, dropShadowAlpha } = style;\r\n            const x = Math.round(Math.cos(dropShadowAngle) * dropShadowDistance);\r\n            const y = Math.round(Math.sin(dropShadowAngle) * dropShadowDistance);\r\n            let color = dropShadowColor;\r\n\r\n            // Convert numbers to hex strings\r\n            if (typeof color === 'number')\r\n            {\r\n                color = hex2string(color);\r\n            }\r\n\r\n            // Check if we should apply alpha\r\n            if (color.charAt(0) === '#' && dropShadowAlpha < 1)\r\n            {\r\n                const [r, g, b] = hex2rgb(parseInt(color.replace('#', ''), 16));\r\n\r\n                color = `rgba(${r * 255 | 0}, ${g * 255 | 0}, ${b * 255 | 0}, ${dropShadowAlpha})`;\r\n            }\r\n\r\n            css += `text-shadow: ${x}px ${y}px ${dropShadowBlur}px ${color};`;\r\n        }\r\n\r\n        const svg = `\r\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"2048\" height=\"2048\">\r\n                <foreignObject width=\"100%\" height=\"100%\">\r\n                    <div xmlns=\"http://www.w3.org/1999/xhtml\" class=\"pixi-html_text\" style=\"${css}\">\r\n                        ${this._text}\r\n                        <style>\r\n                            ${this.stringCssStyle}\r\n                        </style>\r\n                    </div>\r\n                </foreignObject>\r\n            </svg>\r\n       `;\r\n\r\n        // Used to measure to D\r\n        const template = this._parser.parseFromString(svg, 'text/xml');\r\n        const div = template.firstChild.querySelector('div');\r\n\r\n        document.body.appendChild(div);\r\n        const { width, height } = div.getBoundingClientRect();\r\n\r\n        document.body.removeChild(div);\r\n\r\n        canvas.width = Math.ceil((Math.max(1, width) + (style.padding * 2)) * resolution);\r\n        canvas.height = Math.ceil((Math.max(1, height) + (style.padding * 2)) * resolution);\r\n\r\n        context.scale(resolution, resolution);\r\n        context.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n        if (!this._loading)\r\n        {\r\n            const image = this._image;\r\n\r\n            this._loading = true;\r\n            image.src = `data:image/svg+xml,${encodeURIComponent(svg)}`;\r\n            image.onload = () =>\r\n            {\r\n                context.drawImage(\r\n                    image,\r\n                    0, 0, width, height,\r\n                    0, 0, width, height,\r\n                );\r\n                image.onload = undefined;\r\n                image.src = '';\r\n                this._loading = false;\r\n                this.updateTexture();\r\n            };\r\n            this.updateTexture();\r\n        }\r\n    }\r\n    \r\n    get stringCssStyle()\r\n    {\r\n        let css = '';\r\n        for (let k in this._cssStyle)\r\n        {\r\n            css += `.pixi-html_text ${k} {${this._cssStyle[k]}}`\r\n        }\r\n        return css;\r\n    }\r\n\r\n    /**\r\n     * Update the texture resource.\r\n     * @private\r\n     */\r\n    updateTexture()\r\n    {\r\n        const { canvas, context, style, texture, resolution } = this;\r\n\r\n        if (style.trim)\r\n        {\r\n            const { width, height, data } = trimCanvas(canvas);\r\n\r\n            if (data)\r\n            {\r\n                canvas.width = width;\r\n                canvas.height = height;\r\n                context.putImageData(data, 0, 0);\r\n            }\r\n        }\r\n\r\n        const padding = style.trim ? 0 : style.padding;\r\n        const baseTexture = texture.baseTexture;\r\n\r\n        texture.trim.width = texture._frame.width = Math.ceil(canvas.width / resolution);\r\n        texture.trim.height = texture._frame.height = Math.ceil(canvas.height / resolution);\r\n        texture.trim.x = -padding;\r\n        texture.trim.y = -padding;\r\n\r\n        texture.orig.width = texture._frame.width - (padding * 2);\r\n        texture.orig.height = texture._frame.height - (padding * 2);\r\n\r\n        // call sprite onTextureUpdate to update scale if _width or _height were set\r\n        this._onTextureUpdate();\r\n\r\n        baseTexture.setRealSize(canvas.width, canvas.height, resolution);\r\n\r\n        this.dirty = false;\r\n    }\r\n\r\n    /**\r\n     * Renders the object using the WebGL renderer\r\n     *\r\n     * @param {PIXI.Renderer} renderer - The renderer\r\n     * @private\r\n     */\r\n    _render(renderer)\r\n    {\r\n        if (this._autoResolution && this._resolution !== renderer.resolution)\r\n        {\r\n            this._resolution = renderer.resolution;\r\n            this.dirty = true;\r\n        }\r\n\r\n        this.updateText(true);\r\n\r\n        super._render(renderer);\r\n    }\r\n\r\n    /**\r\n     * Renders the object using the Canvas Renderer.\r\n     *\r\n     * @private\r\n     * @param {PIXI.CanvasRenderer} renderer - The renderer\r\n     */\r\n    _renderCanvas(renderer)\r\n    {\r\n        if (this._autoResolution && this._resolution !== renderer.resolution)\r\n        {\r\n            this._resolution = renderer.resolution;\r\n            this.dirty = true;\r\n        }\r\n\r\n        this.updateText(true);\r\n\r\n        super._renderCanvas(renderer);\r\n    }\r\n\r\n    /**\r\n     * Get the local bounds.\r\n     *\r\n     * @param {PIXI.Rectangle} [rect]\r\n     * @return {PIXI.Rectangle} Local bounds\r\n     */\r\n    getLocalBounds(rect)\r\n    {\r\n        this.updateText(true);\r\n\r\n        return super.getLocalBounds(rect);\r\n    }\r\n\r\n    _calculateBounds()\r\n    {\r\n        this.updateText(true);\r\n        this.calculateVertices();\r\n        // if we have already done this on THIS frame.\r\n        this._bounds.addQuad(this.vertexData);\r\n    }\r\n\r\n    /**\r\n     * Handle dirty style changes\r\n     * @private\r\n     */\r\n    _onStyleChange()\r\n    {\r\n        this.dirty = true;\r\n    }\r\n\r\n    /**\r\n     * Destroy this Text object. Don't use after calling.\r\n     * @param {boolean|object} [options=true] Same as Sprite destroy options.\r\n     */\r\n    destroy(options = true)\r\n    {\r\n        super.destroy(options);\r\n\r\n        // make sure to reset the the context and canvas..\r\n        // dont want this hanging around in memory!\r\n        this.context = null;\r\n        this.canvas.width = this.canvas.height = 0; // Safari hack\r\n        this.canvas = null;\r\n        this._style = null;\r\n        this._cssStyle = null;\r\n        this._parser = null;\r\n        this._image.onload = null;\r\n        this._image.src = '';\r\n        this._image = null;\r\n    }\r\n\r\n    /**\r\n     * Get the width in pixels.\r\n     * @member {number}\r\n     */\r\n    get width()\r\n    {\r\n        this.updateText(true);\r\n\r\n        return Math.abs(this.scale.x) * this._texture.orig.width;\r\n    }\r\n\r\n    set width(value) // eslint-disable-line require-jsdoc\r\n    {\r\n        this.updateText(true);\r\n\r\n        const s = sign(this.scale.x) || 1;\r\n\r\n        this.scale.x = s * value / this._texture.orig.width;\r\n        this._width = value;\r\n    }\r\n\r\n    /**\r\n     * Get the height in pixels.\r\n     * @member {number}\r\n     */\r\n    get height()\r\n    {\r\n        this.updateText(true);\r\n\r\n        return Math.abs(this.scale.y) * this._texture.orig.height;\r\n    }\r\n\r\n    set height(value) // eslint-disable-line require-jsdoc\r\n    {\r\n        this.updateText(true);\r\n\r\n        const s = sign(this.scale.y) || 1;\r\n\r\n        this.scale.y = s * value / this._texture.orig.height;\r\n        this._height = value;\r\n    }\r\n\r\n    /**\r\n     * The base style to render with text.\r\n     * @member {PIXI.Style|object}\r\n     */\r\n    get style()\r\n    {\r\n        return this._style;\r\n    }\r\n\r\n    set style(style) // eslint-disable-line require-jsdoc\r\n    {\r\n        style = style || {};\r\n\r\n        if (style instanceof TextStyle)\r\n        {\r\n            this._style = style;\r\n        }\r\n        else\r\n        {\r\n            this._style = new TextStyle(style);\r\n        }\r\n\r\n        this.localStyleID = -1;\r\n        this.dirty = true;\r\n    }\r\n\r\n    /**\r\n     * The CSS style to render with text.\r\n     * @member {string}\r\n     */\r\n    get cssStyle()\r\n    {\r\n        return this._cssStyle;\r\n    }\r\n\r\n    set cssStyle(style) // eslint-disable-line require-jsdoc\r\n    {\r\n        this._cssStyle = style || {};\r\n        this.dirty = true;\r\n    }\r\n\r\n    /**\r\n     * Contents of text. This can be HTML text.\r\n     * @member {string}\r\n     */\r\n    get text()\r\n    {\r\n        return this._text;\r\n    }\r\n\r\n    set text(text) // eslint-disable-line require-jsdoc\r\n    {\r\n        text = String(text === '' || text === null || text === undefined ? ' ' : text);\r\n\r\n        if (this._text === text)\r\n        {\r\n            return;\r\n        }\r\n        this._text = text;\r\n        this.dirty = true;\r\n    }\r\n\r\n    /**\r\n     * The resolution / device pixel ratio of the canvas.\r\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\r\n     * @member {number}\r\n     * @default 1\r\n     */\r\n    get resolution()\r\n    {\r\n        return this._resolution;\r\n    }\r\n\r\n    set resolution(value) // eslint-disable-line require-jsdoc\r\n    {\r\n        this._autoResolution = false;\r\n\r\n        if (this._resolution === value)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this._resolution = value;\r\n        this.dirty = true;\r\n    }\r\n}\r\n"],"names":["HTMLText","text","style","canvas","cssStyle","document","createElement","width","height","const","texture","Texture","from","scaleMode","settings","SCALE_MODE","orig","Rectangle","trim","super","this","_parser","DOMParser","_image","Image","context","getContext","_resolution","RESOLUTION","_autoResolution","_text","_style","_cssStyle","_loading","localStyleID","updateText","respectDirty","styleID","dirty","let","css","lineHeight","wordWrap","breakWords","strokeThickness","color","stroke","hex2string","dropShadow","x","Math","round","cos","dropShadowAngle","dropShadowDistance","y","sin","dropShadowColor","charAt","dropShadowAlpha","hex2rgb","parseInt","replace","dropShadowBlur","svg","div","parseFromString","firstChild","querySelector","body","appendChild","getBoundingClientRect","removeChild","ceil","max","padding","resolution","scale","clearRect","image","src","encodeURIComponent","onload","drawImage","undefined","updateTexture","prototypeAccessors","stringCssStyle","k","trimCanvas","data","putImageData","baseTexture","_frame","_onTextureUpdate","setRealSize","_render","renderer","_renderCanvas","getLocalBounds","rect","_calculateBounds","calculateVertices","_bounds","addQuad","vertexData","_onStyleChange","destroy","options","abs","_texture","value","s","sign","_width","_height","TextStyle","String","Sprite"],"mappings":"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"}